---
title: 'If a function is ever called'
date: 2026-02-02
permalink: /posts/2026/02/uprobe/
tags:
  - Articles
  - Uprobe
---
Given a large C project and I want to know if a vulnerable function is ever being used by the test cases, how to find it?


## CVE

Let’s use `CVE-2025-11187` as an example. From the GitHub commit history, we can see that the vulnerable function is `PBMAC1_PBKDF2_HMAC`, which is defined in **crypto/pkcs12/p12_mutl.c**.

To identify which OpenSSL API functions use this function, one naive approach is to manually search the codebase for the function name. Based on this approach, I found the following call chain:
```bash
test_PKCS12_set_pbmac1_pbkdf2_saltlen_zero(pkcs12_api_test.c) -> 
PKCS12_set_pbmac1_pbkdf2(p12_mutl.c) ->
PBMAC1_PBKDF2_HMAC(p12_mutl.c)
```

What I have done so far is static analysis. However, the remaining question is: will this vulnerable function actually be called at runtime?

## Uprobe and bpftrace

Uprobes are a feature of the Linux kernel that allow you to trace the execution of user-space functions at runtime. They are lightweight and do not require any changes to the target application’s source code. bpftrace is a tracing tool that can attach to uprobes and observe function execution in a simple and expressive way.

To use these tools, it is necessary to compile the project with debug symbols enabled:

```bash
make "CFLAGS=-g -O0"
```
The OpenSSL project includes built-in test suites that can be invoked using `make test`. Running these tests allows us to determine whether any cryptographic operations will invoke the vulnerable function at runtime.

## Identify where the vulnerable function is located

If you look at the file path of the vulnerable function, you will notice that it resides under the crypto directory. This means that when you run 'make', the files in crypto are compiled into the shared library **libcrypto.so**, which is one of the most important and widely used shared libraries in OpenSSL.

If you search the OpenSSL API documentation, you will find that `PKCS12_set_pbmac1_pbkdf2` is a public API function exposed through a header file, whereas `PBMAC1_PBKDF2_HMAC` is an internal function.

We can verify this using the `-D` option of `nm`, which lists the defined (exported) symbols of a shared library. Exported symbols are functions that are visible to and usable by external programs:

```bash
$ nm -D --defined-only libcrypto.so | grep PKCS12_set_pbmac1_pbkdf2
000000000037a87a T PKCS12_set_pbmac1_pbkdf2@@OPENSSL_4.0.0
```
Meanwhile, we can use the -a option to display all symbols, including debugger-only symbols. These symbols are present because the project was compiled with the -g flag. Under normal circumstances, programs linking against the shared library do not need to resolve internal function names; however, when using a debugger such as gdb, these symbols become relevant.

```bash
$ nm -a /mnt/linuxstorage/openssl/libcrypto.so | grep -w -a PBMAC1_PBKDF2_HMAC
000000000037957d t PBMAC1_PBKDF2_HMAC
```


## use bpftrace to trace the execution 

Now when we launch this command and run the test suite by make test in another terminal, we should be able to see what executable calls the vulnerable function. Here `comm` is the name of the executable, `pid` is the process ID, `tid` is the thread ID.

```bash
$ sudo bpftrace -e '
uprobe:/mnt/linuxstorage/openssl/libcrypto.so:PKCS12_set_pbmac1_pbkdf2
{
  printf("HIT PKCS12_set_pbmac1_pbkdf2 comm=%s pid=%d tid=%d\n", comm, pid, tid);
}

uprobe:/mnt/linuxstorage/openssl/libcrypto.so:PBMAC1_PBKDF2_HMAC
{
  printf("HIT PBMAC1_PBKDF2_HMAC comm=%s pid=%d tid=%d\n", comm, pid, tid);
}'
```

For the internal function, we can also specify the address offset of the function.
```bash
$ sudo bpftrace -e '
uprobe:/mnt/linuxstorage/openssl/libcrypto.so:0x37957d
{
  printf("HIT PBMAC1_PBKDF2_HMAC comm=%s pid=%d tid=%d\n", comm, pid, tid);
}'
```

This is the output we got:

```bash
Attaching 2 probes...
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=83318 tid=83318
HIT PKCS12_set_pbmac1_pbkdf2 comm=openssl pid=109229 tid=109229
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109303 tid=109303
HIT PKCS12_set_pbmac1_pbkdf2 comm=openssl pid=109369 tid=109369
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109452 tid=109452
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109521 tid=109521
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109593 tid=109593
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109652 tid=109652
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109712 tid=109712
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109712 tid=109712
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109781 tid=109781
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109781 tid=109781
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109841 tid=109841
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109841 tid=109841
HIT PBMAC1_PBKDF2_HMAC comm=openssl pid=109912 tid=109912
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=110657 tid=110657
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=110725 tid=110725
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=110782 tid=110782
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=110848 tid=110848
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=110911 tid=110911
HIT PKCS12_set_pbmac1_pbkdf2 comm=pkcs12_api_test pid=110987 tid=110987
```

surprisingly, the vulnerable function is not called by the expected executable **pkcs12_api_test**, but by **openssl**. The API function `PKCS12_set_pbmac1_pbkdf2` is indeed called by **pkcs12_api_test**. We should not trust static analysis!


## Another example 

`CVE-2025-15467`
```bash
$ nm -a /mnt/linuxstorage/openssl/libcrypto.so | grep -w linebuffer_puts
0000000000124afa t linebuffer_puts


$ sudo bpftrace -e '                                                                      
uprobe:/mnt/linuxstorage/openssl/libcrypto.so:0x124afa
{
  printf("HIT linebuffer_puts (0x124afa) comm=%s pid=%d tid=%d\n", comm, pid, tid);
  print(ustack(10));
}'
```